---
layout: post
title: Spock-Reports with Templates
tags: [spock, asciidoc]
---

The new template engine for the Spock-Reports-Plugin is out. Let's build an asciidoc template with it.

### Step 1: configure the plugin

Renato describes this step in detail on the [Plugin Homepage](https://github.com/renatoathaydes/spock-reports). I've placed the properties file in `src/test/resources/main/META-INF/services/` and so I place my templates also in `src/test/resources/spockreporttemplate/`

```groovy
com.athaydes.spockframework.report.template.TemplateReportCreator.specTemplateFile=/spockreporttemplate/spec-template.ad
com.athaydes.spockframework.report.template.TemplateReportCreator.reportFileExtension=ad
com.athaydes.spockframework.report.template.TemplateReportCreator.summaryTemplateFile=/spockreporttemplate/summary-template.ad
com.athaydes.spockframework.report.template.TemplateReportCreator.summaryFileName=summary.ad
```

Just to get started, I placed two emtpy files `spec-template.ad` and `summary-template.ad` at the right location and ran my tests just to see that those empty templates are picked up.

### Step 2: create a summary template

I'll start with the summary report. It seems to be the easier one. Renato already provided a [markdown sample](https://raw.githubusercontent.com/renatoathaydes/spock-reports/master/src/main/resources/templateReportCreator/summary-template.md), so let's take a look at it to see the data which is available to the template.

So it seems that we have a convinience function (`aggregateStats`) which creates some statistical data about our test runs and the `data` object itself.

Let's modify the empty template in order to output both data structures:

```groovy
<% def stats = com.athaydes.spockframework.report.util.Utils.aggregateStats( data ) %>
${stats.inspect()}
>>>>>>>>>>
${data.inspect()}
```

which leads to the following output: (a little bit reformatted for better readability)

```groovy
['total':13, 'passed':13, 'failed':0, 'fFails':0, 'fErrors':0, 'time':258.0, 'successRate':1.0]
>>>>>>>>>>
['DatabaseDrivenSpec':['failures':0, 'errors':0, 'skipped':0, 'totalRuns':1, 'successRate':1.0, 'time':67], 
	'DataDrivenSpec':['failures':0, 'errors':0, 'skipped':0, 'totalRuns':3, 'successRate':1.0, 'time':19], 
	'DerivedSpec':['failures':0, 'errors':0, 'skipped':0, 'totalRuns':2, 'successRate':1.0, 'time':16], 
	'EmptyStackSpec':['failures':0, 'errors':0, 'skipped':0, 'totalRuns':4, 'successRate':1.0, 'time':20], 
	'HamcrestMatchersSpec':['failures':0, 'errors':0, 'skipped':0, 'totalRuns':1, 'successRate':1.0, 'time':21], 
	'HelloSpockSpec':['failures':0, 'errors':0, 'skipped':0, 'totalRuns':1, 'successRate':1.0, 'time':3], 
	'IncludeExcludeExtensionSpec':['failures':0, 'errors':0, 'skipped':0, 'totalRuns':3, 'successRate':1.0, 'time':3], 
	'OrderedInteractionsSpec':['failures':0, 'errors':0, 'skipped':0, 'totalRuns':1, 'successRate':1.0, 'time':49], 
	'PublisherSpec':['failures':0, 'errors':0, 'skipped':0, 'totalRuns':2, 'successRate':1.0, 'time':24], 
	'StackWithOneElementSpec':['failures':0, 'errors':0, 'skipped':0, 'totalRuns':4, 'successRate':1.0, 'time':4], 
	'StackWithThreeElementsSpec':['failures':0, 'errors':0, 'skipped':0, 'totalRuns':4, 'successRate':1.0, 'time':7], 
	'StepwiseExtensionSpec':['failures':0, 'errors':0, 'skipped':0, 'totalRuns':3, 'successRate':1.0, 'time':4], 
	'UsingJUnitRulesSpec':['failures':0, 'errors':0, 'skipped':0, 'totalRuns':1, 'successRate':1.0, 'time':21]
]
```

That's great! We get hashmaps which can be easily inspected. That will make it even easier to write a template.

Now let's come up with the real template:

```groovy
<% def stats = com.athaydes.spockframework.report.util.Utils.aggregateStats( data )
 %>= Specification run results

== Specifications summary

[small>#created on ${new Date()} by ${System.properties['user.name']}#

.summary
[options="header"]
|==================================================================================================================================
| Total          | Passed          | Failed          | Feature failures | Feature errors   | Success rate        | Total time (ms) 
| ${stats.total} | ${stats.passed} | ${stats.failed} | ${stats.fFails}  | ${stats.fErrors} | ${stats.successRate}| ${stats.time}   
|==================================================================================================================================

== Specifications

[options="header"]
|===================================================================
|Name  | Features | Failed | Errors | Skipped | Success rate | Time 
<% data.each { name, map ->
 %>| $name | ${map.totalRuns} | ${map.failures} | ${map.errors} | ${map.skipped} | ${map.successRate} | ${map.time} 
<% } %>
|===================================================================

[small]#generated by ${com.athaydes.spockframework.report.SpockReportExtension.PROJECT_URL}[Athaydes Spock Reports]#
```

Since MarkDown and AsciiDoc do not differ too much for this template, this was easy! Details regarding the formatting can be solved later...

### Step 3: create a spec template

Now let's do the same with the spec template. First try to figure out what data we will have available. 

```groovy
${data.dump()}
```

but this time, the dump does not give us such a good result: (reformatted for readability)

```groovy
<com.athaydes.spockframework.report.internal.SpecData@5de17399 
info=org.spockframework.runtime.model.SpecInfo@7c6c71f5
featureRuns=[
	com.athaydes.spockframework.report.internal.FeatureRun@33adcba4,
	com.athaydes.spockframework.report.internal.FeatureRun@5714967d,
	com.athaydes.spockframework.report.internal.FeatureRun@8a41535
	] 
totalTime=10>
```

We can only see the different java object within the dump and not the full data structure. Since I don't like to go to the source of those structure and analyze it, I now take the MarkDown sample template and start to transform it right away. This should lead to a solution which will fit for the moment:



(to be continued)

